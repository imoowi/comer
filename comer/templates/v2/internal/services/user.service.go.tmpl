/*
generated by comer,https://github.com/imoowi/comer
Copyright © 2023 jun<simpleyuan@gmail.com>
*/
package services

import (
	"errors"

	"github.com/gin-gonic/gin"
	"github.com/imoowi/comer/utils/maker"
	"github.com/imoowi/comer/utils/password"
	"{{.moduleName}}/internal/global"
	"{{.moduleName}}/internal/middlewares/token"
	"{{.moduleName}}/internal/models"
	"{{.moduleName}}/internal/repos"
	"github.com/spf13/cast"
	"github.com/imoowi/comer/interfaces/impl"
)

var User *UserService

type UserService struct {
	impl.Service[*models.User]
}

func NewUserService(r *repos.UserRepo) *UserService {
	return &UserService{
		Service: *impl.NewService[*models.User](r),
	}
}
func init() {
	RegisterServices(func() {
		User = NewUserService(repos.User)
	})
}
func (s *UserService) OneByUsername(c *gin.Context, username string) (model *models.User, err error) {
	return repos.User.OneByUsername(c, username)
}
func (s *UserService) Add(c *gin.Context, _model *models.UserAdd) (newId uint, err error) {
	admin, _ := s.One(c, c.GetUint(`uid`))
	// 角色是否存在？
	role, _ := Role.One(c, _model.RoleId)
	if role == nil || (*role).GetID() <= 0 {
		newId = 0
		err = errors.New(`角色不存在`)
		return
	}
	// 用户是否存在？
	model, _ := repos.User.OneByUsername(c, _model.Username)
	if model != nil && model.ID > 0 {
		newId = 0
		err = errors.New(`用户名已经存在`)
		return
	}
	salt := maker.MakeRandStr(6)
	newUser := &models.User{
		UserBase: models.UserBase{
			Username: _model.Username,
			// Passwd:   _model.Passwd,
			Passwd: password.GeneratePassword(_model.Passwd + salt),
			Salt:   salt,
		},
	}
	newId, err = s.Service.Add(c, &f, newUser)
	if newId > 0 {
		// 插入用户和角色关系
		userrole := &models.UserRole{UserID: newId, RoleId: _model.RoleId}
		UserRole.Add(c, userrole)

		//*
		go func(c *gin.Context, _model *models.UserAdd, newId uint) {

			if admin.GetID() > 0 {
				userlog := &models.UserLog{
					UserID:     admin.GetID(),
					LogType:    global.USER_LOG_TYPE_ADD,
					ResType:    global.RES_TYPE_USER,
					LogContent: `管理员【` + admin.Username + `】添加了用户【` + cast.ToString(newId) + `】`,
					IP:         c.ClientIP(),
				}
				UserLog.Add(c, userlog)
			}
		}(c, _model, newId)
		//*/

	}
	return
}
func (s *UserService) Login(c *gin.Context, login *models.UserLogin) (user *models.User, err error) {
	user, err = repos.User.Login(c, login)
	return
}
func (s *UserService) Logout(c *gin.Context, token string) bool {
	// err := global.Redis.SAdd(c, JwtTokenBlackListSetKey, token).Err()
	var err error
	admin, _ := repos.User.One(c, c.GetUint(`uid`))
	if (*admin).GetID() > 0 {
		go func(c *gin.Context, admin *models.User) {
			userlog := &models.UserLog{
				UserID:     admin.ID,
				LogType:    global.USER_LOG_TYPE_USER_LOGOUT,
				ResType:    global.RES_TYPE_USER,
				LogContent: `用户【` + admin.Username + `】退出了系统`,
				IP:         c.ClientIP(),
			}
			UserLog.Add(c, userlog)
		}(c, admin)
	}
	return err == nil
}

func (s *UserService) ChgPwd(c *gin.Context, userChgPwd *models.UserChgPwd) (newToken string, err error) {
	admin, _ := repos.User.One(c, c.GetUint(`uid`))
	ok, err := repos.User.ChgPwd(c, userChgPwd)
	if err == nil && ok {
		if (*admin).GetID() > 0 {
			newToken, _ = token.GenToken((*admin).Username, (*admin).ID)
			go func(c *gin.Context, admin *models.User) {
				userlog := &models.UserLog{
					UserID:     admin.ID,
					LogType:    global.USER_LOG_TYPE_USER_CHGPWD,
					ResType:    global.RES_TYPE_USER,
					LogContent: `用户【` + admin.Username + `】修改了密码`,
					IP:         c.ClientIP(),
				}
				UserLog.Add(c, userlog)
			}(c, admin)
		}
	}
	return
}

const JwtTokenBlackListSetKey = `lynkros-monitor:jwt:token:blacklist`

func (s *UserService) IsLogouted(c *gin.Context, token string) bool {
	// ok, _ := global.Redis.SIsMember(c, JwtTokenBlackListSetKey, token).Result()
	var ok bool
	return ok
}
func (s *UserService) IsSuper(c *gin.Context, userId uint) bool {
	userRoles, err := UserRole.AllByUserId(c, userId)
	if err != nil {
		return false
	}
	if len(userRoles) <= 0 {
		return false
	}
	for _, v := range userRoles {
		role, err := Role.One(c, v.RoleId)
		if err != nil {
			continue
		}
		if role.Level == models.ROLE_LEVEL_SUPER {
			return true
		}
	}
	return false
}
func (s *UserService) UserRoleIds(c *gin.Context, userId uint) []uint {
	userRoleIds, err := UserRole.AllIdsByUserId(c, userId)
	if err != nil {
		return make([]uint, 0)
	}
	if len(userRoleIds) > 0 {
		return userRoleIds
	}
	return make([]uint, 0)
}
func (s *UserService) UserRolesByUid(c *gin.Context, userId uint) (roles []*models.Role) {
	userRoles, err := UserRole.AllByUserId(c, userId)
	if err != nil {
		return nil
	}
	if len(userRoles) <= 0 {
		return nil
	}
	for _, v := range userRoles {
		role, err := Role.One(c, v.RoleId)
		if err != nil {
			continue
		}
		roles = append(roles, role)
	}
	return
}
